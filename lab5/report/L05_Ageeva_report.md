---
# Титульный лист
title: |
    Отчёт по лабораторной работе №5  
    Вероятностные алгоритмы проверки чисел на простоту
author:
- "Студент: Агеева Анастасия Сергеевна, 1032212304"
- "Группа: НФИмд-02-21"
- "Преподаватель: Кулябов Дмитрий Сергеевич,"
- "д-р.ф.-м.н., проф."
date: "Москва 2021"

# Generic otions
lang: ru-RU
toc-title: "Содержание"

# Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

# Pdf output format
toc: true # Содержание
toc_depth: 2
lof: true # Список изображений
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
### Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric

## Misc options
indent: true
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text

  - \usepackage{titling}
  - \setlength{\droptitle}{-9em}
  - \pretitle{\begin{center}
      \textbf{РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ}\\
      \textbf{Факультет физико-математических и естественных наук}\\
      \textbf{Кафедра прикладной информатики и теории вероятностей}
      \vspace{9cm}
      \LARGE\\}
  - \posttitle{\vskip 1em \Large \emph{\textit{Дисциплина$:$ Математические основы защиты информации и информационной безопасности}} \end{center}}
  - \preauthor{\vskip 3em \begin{flushright} \large \begin{tabular}[t]{c}}
  - \postauthor{\end{tabular}\par\end{flushright} \vfill \vskip 5em}
---

# Цель работы

Цель данной лабораторной работы изучение алгоритмов проверки чисел на простоту.

# Задание

1.  Реализовать программно алгоритм, реализующий тест Ферма;
1.  Реализовать алгоритм вычисления символа Якоби;
1.  Реализовать программно алгоритм, реализующий тест Соловэя-Штрассена;
1.  Реализовать программно алгоритм, реализующий тест Миллера-Рабина.

# Теоретическое введение

### Простые числа

Просто́е число́ — натуральное (целое положительное) число, имеющее ровно два различных натуральных делителя — единицу и самого себя. Другими словами, число $x$ является простым, если оно больше $1$ и при этом делится без остатка только на $1$ и на $x$. К примеру, $5$ — простое число, а $6$ не является простым числом, так как, помимо $1$ и $6$, оно также делится на $2$ и на $3$ [@numbers].

## Алгоритмы поиска и распознавания простых чисел

Простые способы нахождения начального списка простых чисел вплоть до некоторого значения дают решето Эратосфена, решето Сундарама и решето Аткина.
Однако, на практике вместо получения списка простых чисел зачастую требуется проверить, является ли данное число простым. Алгоритмы, решающие эту задачу, называются тестами простоты. Существует множество полиномиальных тестов простоты, но большинство их являются вероятностными (например, тест Миллера — Рабина) и используются для нужд криптографии. В 2002 году было доказано, что задача проверки на простоту в общем виде полиномиально разрешима, но предложенный детерминированный тест Агравала — Каяла — Саксены имеет довольно большую вычислительную сложность, что затрудняет его практическое применение.
Для некоторых классов чисел существуют специализированные эффективные тесты простоты [@numbers].

### Тесты простоты

**Тестом простоты** (или проверкой простоты) называется алгоритм, который, приняв на входе число, позволяет либо не подтвердить предположение о составности числа, либо точно утверждать его простоту. Во втором случае он называется истинным тестом простоты. Задача теста простоты относится к классу сложности P, то есть время работы алгоритмов её решения зависит от размера входных данных полиномиально, что было доказано в 2002 году. Появление полиномиального алгоритма предсказывалось существованием полиномиальных сертификатов простоты и, как следствие, тем, что задача проверки числа на простоту принадлежала классам NP и co-NP одновременно.

Существующие алгоритмы проверки числа на простоту могут быть разделены на две категории: истинные тесты простоты и вероятностные тесты простоты. Результатом вычислений истинных тестов всегда является факт простоты либо составности числа. Вероятностный тест показывает, является ли число простым с некоторой вероятностью. Числа, удовлетворяющие вероятностному тесту простоты, но являющиеся составными, называются псевдопростыми. Одним из примеров таких чисел являются числа Кармайкла.

Одним из примеров истинных тестов простоты является тест Люка-Лемера для чисел Мерсенна. Очевидный недостаток этого теста заключается в его применимости только к числам определённого вида. 

Среди других примеров можно привести основанные на малой теореме Ферма:

- Тест Пепина для чисел Ферма;
- Теорема Прота для чисел Прота;
- Тест Агравала — Каяла — Саксены (первый универсальный, полиномиальный, детерминированный и безусловный тест простоты);
- Тест Люка — Лемера — Ризеля.

А также:

- метод перебора делителей;
- Теорема Вильсона;
- Критерий Поклингтона;
- Тест Миллера;
- Тест Адлемана — Померанса — Румели, усовершенствованный Коэном и Ленстрой;
- Тест простоты с использованием эллиптических кривых.

К вероятностным тестам простоты относят:

- Тест Ферма [@ferma];
- Тест Миллера — Рабина [@miller];
- Тест Соловея — Штрассена [@solovey];
- Тест Бейли — Померанца — Селфриджа — Уогстаффа.

## Тест Ферма

Если $n$ — *простое* число, то оно удовлетворяет сравнению $a^{n-1}\equiv 1{\pmod {n}}$ для любого $a$, которое не делится на $n$.

Выполнение сравнения $a^{n-1}\equiv 1{\pmod {n}}$ является необходимым, но не достаточным признаком простоты числа. То есть, если найдётся хотя бы одно a, для которого $a^{n-1}\not \equiv 1{\pmod {n}}$ то число $n$ — составное; в противном случае ничего сказать нельзя, хотя шансы на то, что число является простым, увеличиваются. Если для составного числа n выполняется сравнение $a^{n-1}\equiv 1{\pmod {n}}$, то число $n$ называют *псевдопростым* по основанию $a$ . При проверке числа на простоту тестом Ферма выбирают несколько чисел a. Чем больше количество a, для которых $a^{n-1}\equiv 1{\pmod {n}}$, тем больше шансы, что число n простое. Однако существуют составные числа, для которых сравнение $a^{n-1}\equiv 1{\pmod {n}}$ выполняется для всех $a$, взаимно простых с $n$ — это *числа Кармайкла*. Чисел Кармайкла — бесконечное множество, наименьшее число Кармайкла — 561. Тем не менее, тест Ферма довольно эффективен для обнаружения составных чисел.

## Тест Соловея-Штрассена

**Тест Соловея — Штрассена** — вероятностный тест простоты, открытый в 1970-х годах Робертом Мартином Соловеем совместно с Фолькером Штрассеном. Тест всегда корректно определяет, что простое число является простым, но для составных чисел с некоторой вероятностью он может дать неверный ответ. Основное преимущество теста заключается в том, что он, в отличие от теста Ферма, распознает числа Кармайкла как составные.

### Обоснование

Тест Соловея — Штрассена опирается на малую теорему Ферма и свойства символа Якоби [@yakobi]:
Если $n$ — нечетное составное число, то количество целых чисел $a$, взаимнопростых с $n$ и меньших $n$, удовлетворяющих сравнению $\textstyle a^{(n-1)/2}\equiv \left({\frac {a}{n}}\right){\pmod {n}}$, не превосходит ${\frac {n}{2}}$.
Составные числа $n$ удовлетворяющие этому сравнению называются псевдопростыми Эйлера-Якоби по основанию $a$.

### Символ Якоби

Пусть $P$ — нечётное, большее единицы число и $P={p}_{1}{p}_{2}\ldots {p}_{n}$ — его разложение на простые множители (среди $p_{1},\;\ldots ,\;p_{n}$ могут быть равные). Тогда для произвольного целого числа $a$ символ Якоби определяется равенством:
$\left({\frac {a}{P}}\right)=\left({\frac {a}{p_{1}}}\right)\left({\frac {a}{p_{2}}}\right)\cdots \left({\frac {a}{p_{n}}}\right),$
где $\left({\frac {a}{p_{i}}}\right)$— символы Лежандра.
По определению считаем, что $\left({\frac {a}{1}}\right)=1$ для всех $a$.

Символ Якоби практически никогда не вычисляют по определению. Чаще всего для вычисления используют свойства символа Якоби, главным образом — квадратичный закон взаимности.

Cимвол Якоби нельзя напрямую использовать для проверки разрешимости квадратичного сравнения. То есть, если задано сравнение
$x^{2}\equiv a\mod n,$	((1))
то равенство единице символа Якоби $\left({\frac {a}{n}}\right)$ вовсе не означает, что данное сравнение разрешимо. Например, $\left({\frac {2}{15}}\right)=(-1)^{28}=1$, но сравнение $x^{2}\equiv 2\mod {15}$ не имеет решений (можно проверить перебором).
Но если $\left({\frac {a}{n}}\right)=-1$, то сравнение (1) не имеет решений.

## Тест Миллера-Рабина

Тест Миллера — Рабина — вероятностный полиномиальный тест простоты. Тест Миллера — Рабина, наряду с тестом Ферма и тестом Соловея — Штрассена, позволяет эффективно определить, является ли данное число составным. Однако, с его помощью нельзя строго доказать простоту числа. Тем не менее тест Миллера — Рабина часто используется в криптографии для получения больших случайных простых чисел.

Как и тесты Ферма и Соловея — Штрассена, тест Миллера — Рабина опирается на проверку ряда равенств, которые выполняются для простых чисел. Если хотя бы одно такое равенство не выполняется, это доказывает что число составное.

Для теста Миллера — Рабина используется следующее утверждение:

Пусть $n$ — простое число и $n-1=2^{s}d$, где $d$ — нечётно. Тогда для любого $a$ из ${Z}_{n}$ выполняется хотя бы одно из условий:

1. $a^{d}\equiv 1{\pmod {n}}$;
2. Существует целое число $r<s$, такое что $a^{2^{r}d}\equiv -1{\pmod {n}}$.

# Выполнение лабораторной работы

Для выполнения работы импортирую библиотеку random, поскольку понадобится генерация случайных чисел.

![Импорт библиотеки random](image/import.jpg){#fig:001 width="70%"}

1. **Реализация теста Ферма**

   1. Задам функцию *ferma()*, в которую буду передавать число *n*, проверяемое на простоту. По алгоритму, реализующему тест Ферма, осуществляется проверка простоты числа. В качестве результата возвращается строка, сообщающая простое/составное число или выдающая сообщение об ошибке, в случае ввода некорректных данных. 

      ![Реализация теста Ферма](image/ferma_function.jpg){#fig:002 width="70%"}

   2. Вызову функцию для чисел 8 и 7. Алгоритм верно проверяет простоту чисел.

      ![Результаты теста Ферма](image/ferma_results.jpg){#fig:003 width="70%"}

2. **Реализация алгоритма вычисления символа Якоби**

   1. Задам функцию *yakobi()*, в которую буду передавать два числа *a* и *n*. По алгоритму вычисления символа Якоби функция возвращает -1, 0, 1 или сообщение об ошибке, в случае ввода некорректных данных (работа программы прекращается). 

      ![Реализация алгоритма вычисления символа Якоби](image/yakobi_fuction.jpg){#fig:004 width="70%"}

   2. Вызову функцию для пар чисел (4, 13) и (4, 2). Алгоритм верно находит символ Якоби для первой пары чисел и выдает сообщение об ошибке для второй пары чисел.

      ![Результаты алгоритма вычисления символа Якоби](image/yakobi_results.jpg){#fig:005 width="70%"}

3. **Реализация теста Соловэя-Штрассена**

   1. Задам функцию *solovey()*, в которую буду передавать число *n*, проверяемое на простоту. По алгоритму, реализующему тест Соловэя-Штрассена и использующему число Якоби, осуществляется проверка простоты числа. В качестве результата возвращается строка, сообщающая простое/составное число или выдающая сообщение об ошибке, в случае ввода некорректных данных. 

      ![Реализация теста Соловэя-Штрассена](image/solovey_function.jpg){#fig:006 width="70%"}

   2. Вызову функцию для чисел 11 и 9. Алгоритм верно проверяет простоту чисел.
      
      ![Результаты теста Соловэя-Штрассена](image/solovey_results.jpg){#fig:007 width="70%"}

4. **Реализация теста Миллера-Рабина**

   1. Задам функцию *miller()*, в которую буду передавать число *n*, проверяемое на простоту. По алгоритму, реализующему тест Миллера-Рабина, осуществляется проверка простоты числа. В качестве результата возвращается строка, сообщающая простое/составное число или выдающая сообщение об ошибке, в случае ввода некорректных данных.
   
      ![Реализация теста Миллера-Рабина](image/miller_function.jpg){#fig:008 width="70%"}
   
   2.  Вызову функцию для чисел 9 и 11. Алгоритм верно проверяет простоту чисел.

      ![Результаты теста Миллера-Рабина](image/miller_results.jpg){#fig:009 width="70%"}

# Выводы

В ходе данной лабораторной работы я реализовала три алгоритма проверки числа на простоту, а также алгоритм нахождения числа Якоби.

# Список литературы {#список-литературы .unnumbered}

::: {#refs}
:::
